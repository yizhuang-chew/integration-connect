function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function defineError(statusCode, message) {
  var meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // eslint-disable-next-line no-multi-assign
  this.status = this.statusCode = this.code = statusCode;
  this.message = message;
  Object.assign(this, meta);
  this.name = this.constructor.name; // eslint-disable-next-line no-proto

  this.constructor.prototype.__proto__ = Error.prototype;
  if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
}
/* eslint-disable max-len, flowtype/require-parameter-type */


function NetworkError() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  defineError.call.apply(defineError, [this, 0
  /* special code to indicate network errors */
  ].concat(args));
}
function HttpError() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  defineError.call.apply(defineError, [this].concat(args));
}
function BadRequest() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  defineError.call.apply(defineError, [this, 400].concat(args));
}
function Unauthorized() {
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  defineError.call.apply(defineError, [this, 401].concat(args));
}
function Forbidden() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  defineError.call.apply(defineError, [this, 403].concat(args));
}
function NotFound() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  defineError.call.apply(defineError, [this, 404].concat(args));
}
function ConcurrentModification() {
  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    args[_key7] = arguments[_key7];
  }

  defineError.call.apply(defineError, [this, 409].concat(args));
}
function InternalServerError() {
  for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
    args[_key8] = arguments[_key8];
  }

  defineError.call.apply(defineError, [this, 500].concat(args));
}
function ServiceUnavailable() {
  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    args[_key9] = arguments[_key9];
  }

  defineError.call.apply(defineError, [this, 503].concat(args));
}
/* eslint-enable max-len */

function getErrorByCode(code) {
  switch (code) {
    case 0:
      return NetworkError;

    case 400:
      return BadRequest;

    case 401:
      return Unauthorized;

    case 403:
      return Forbidden;

    case 404:
      return NotFound;

    case 409:
      return ConcurrentModification;

    case 500:
      return InternalServerError;

    case 503:
      return ServiceUnavailable;

    default:
      return undefined;
  }
}

var errors = /*#__PURE__*/Object.freeze({
  __proto__: null,
  NetworkError: NetworkError,
  HttpError: HttpError,
  BadRequest: BadRequest,
  Unauthorized: Unauthorized,
  Forbidden: Forbidden,
  NotFound: NotFound,
  ConcurrentModification: ConcurrentModification,
  InternalServerError: InternalServerError,
  ServiceUnavailable: ServiceUnavailable,
  'default': getErrorByCode
});

function parseHeaders(headers) {
  if (headers.raw) // node-fetch
    return headers.raw(); // Tmp fix for Firefox until it supports iterables

  if (!headers.forEach) return {}; // whatwg-fetch

  var map = {};
  headers.forEach(function (value, name) {
    map[name] = value;
  });
  return map;
}

var _excluded = ["statusCode", "message"];

function createError(_ref) {
  var statusCode = _ref.statusCode,
      message = _ref.message,
      rest = _objectWithoutProperties(_ref, _excluded);

  var errorMessage = message || 'Unexpected non-JSON error response';
  if (statusCode === 404) errorMessage = "URI not found: ".concat(rest.originalRequest.uri);
  var ResponseError = getErrorByCode(statusCode);
  if (ResponseError) return new ResponseError(errorMessage, rest);
  return new HttpError(statusCode, errorMessage, rest);
} // calculates the delay duration exponentially
// More info about the algorithm use here https://goo.gl/Xk8h5f


function calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay) {
  if (backoff) return retryCount !== 0 // do not increase if it's the first retry
  ? Math.min(Math.round((Math.random() + 1) * retryDelay * Math.pow(2, retryCount)), maxDelay) : retryDelay;
  return retryDelay;
}

function maskAuthData(request, maskSensitiveHeaderData) {
  if (maskSensitiveHeaderData) {
    if (request.headers.authorization) request.headers.authorization = 'Bearer ********';
    if (request.headers.Authorization) request.headers.Authorization = 'Bearer ********';
  }
}

function createHttpMiddleware(_ref2) {
  var host = _ref2.host,
      credentialsMode = _ref2.credentialsMode,
      includeResponseHeaders = _ref2.includeResponseHeaders,
      includeOriginalRequest = _ref2.includeOriginalRequest,
      _ref2$maskSensitiveHe = _ref2.maskSensitiveHeaderData,
      maskSensitiveHeaderData = _ref2$maskSensitiveHe === void 0 ? true : _ref2$maskSensitiveHe,
      enableRetry = _ref2.enableRetry,
      timeout = _ref2.timeout,
      _ref2$retryConfig = _ref2.retryConfig;
  _ref2$retryConfig = _ref2$retryConfig === void 0 ? {} : _ref2$retryConfig;
  var _ref2$retryConfig$max = _ref2$retryConfig.maxRetries,
      maxRetries = _ref2$retryConfig$max === void 0 ? 10 : _ref2$retryConfig$max,
      _ref2$retryConfig$bac = _ref2$retryConfig.backoff,
      backoff = _ref2$retryConfig$bac === void 0 ? true : _ref2$retryConfig$bac,
      _ref2$retryConfig$ret = _ref2$retryConfig.retryDelay,
      retryDelay = _ref2$retryConfig$ret === void 0 ? 200 : _ref2$retryConfig$ret,
      _ref2$retryConfig$max2 = _ref2$retryConfig.maxDelay,
      maxDelay = _ref2$retryConfig$max2 === void 0 ? Infinity : _ref2$retryConfig$max2,
      _ref2$retryConfig$ret2 = _ref2$retryConfig.retryOnAbort,
      retryOnAbort = _ref2$retryConfig$ret2 === void 0 ? false : _ref2$retryConfig$ret2,
      _ref2$retryConfig$ret3 = _ref2$retryConfig.retryCodes,
      retryCodes = _ref2$retryConfig$ret3 === void 0 ? [503] : _ref2$retryConfig$ret3,
      fetcher = _ref2.fetch,
      _abortController = _ref2.abortController,
      getAbortController = _ref2.getAbortController;
  if (!fetcher && typeof fetch === 'undefined') throw new Error('`fetch` is not available. Please pass in `fetch` as an option or have it globally available.');
  if (timeout && !getAbortController && !_abortController && typeof AbortController === 'undefined') throw new Error('`AbortController` is not available. Please pass in `getAbortController` as an option or have AbortController globally available when using timeout.');
  var fetchFunction;

  if (fetcher) {
    fetchFunction = fetcher;
  } else {
    // `fetcher` is set here rather than the destructuring to ensure fetch is
    // declared before referencing it otherwise it would cause a `ReferenceError`.
    // For reference of this pattern: https://github.com/apollographql/apollo-link/blob/498b413a5b5199b0758ce898b3bb55451f57a2fa/packages/apollo-link-http/src/httpLink.ts#L49
    fetchFunction = fetch;
  }

  if (!Array.isArray(retryCodes)) {
    throw new Error('`retryCodes` option must be an array of retry status (error) codes.');
  }

  return function (next) {
    return function (request, response) {
      var abortController;
      var url = host.replace(/\/$/, '') + request.uri;

      var requestHeader = _objectSpread2({}, request.headers); // If no content-type is provided, defaults to application/json


      if (!(Object.prototype.hasOwnProperty.call(requestHeader, 'Content-Type') || Object.prototype.hasOwnProperty.call(requestHeader, 'content-type'))) {
        requestHeader['Content-Type'] = 'application/json';
      } // Unset the content-type header if explicitly asked to (passing `null` as value).


      if (requestHeader['Content-Type'] === null) {
        delete requestHeader['Content-Type'];
      }

      var body = ['application/json', 'application/graphql'].indexOf(requestHeader['Content-Type']) > -1 && typeof request.body === 'string' || Buffer.isBuffer(request.body) ? request.body : JSON.stringify(request.body || undefined);

      if (body && (typeof body === 'string' || Buffer.isBuffer(body))) {
        requestHeader['Content-Length'] = Buffer.byteLength(body).toString();
      }

      var fetchOptions = {
        method: request.method,
        headers: requestHeader
      };

      if (credentialsMode) {
        fetchOptions.credentials = credentialsMode;
      }

      if (!retryOnAbort) {
        if (timeout || getAbortController || _abortController) {
          // eslint-disable-next-line
          abortController = (getAbortController ? getAbortController() : null) || _abortController || new AbortController();

          if (abortController) {
            fetchOptions.signal = abortController.signal;
          }
        }
      }

      if (body) {
        fetchOptions.body = body;
      }

      var retryCount = 0; // wrap in a fn so we can retry if error occur

      function executeFetch() {
        if (retryOnAbort) {
          if (timeout || getAbortController || _abortController) {
            // eslint-disable-next-line
            abortController = (getAbortController ? getAbortController() : null) || _abortController || new AbortController();

            if (abortController) {
              fetchOptions.signal = abortController.signal;
            }
          }
        } // Kick off timer for abortController directly before fetch.


        var timer;
        if (timeout) timer = setTimeout(function () {
          abortController.abort();
        }, timeout);
        fetchFunction(url, fetchOptions).then(function (res) {
          if (res.ok) {
            if (fetchOptions.method === 'HEAD') {
              next(request, _objectSpread2(_objectSpread2({}, response), {}, {
                statusCode: res.status
              }));
              return;
            }

            res.text().then(function (result) {
              // Try to parse the response as JSON
              var parsed;

              try {
                parsed = result.length > 0 ? JSON.parse(result) : {};
              } catch (err) {
                if (enableRetry && retryCount < maxRetries) {
                  setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
                  retryCount += 1;
                  return;
                }

                parsed = result;
              }

              var parsedResponse = _objectSpread2(_objectSpread2({}, response), {}, {
                body: parsed,
                statusCode: res.status
              });

              if (includeResponseHeaders) parsedResponse.headers = parseHeaders(res.headers);

              if (includeOriginalRequest) {
                parsedResponse.request = _objectSpread2({}, fetchOptions);
                maskAuthData(parsedResponse.request, maskSensitiveHeaderData);
              }

              next(request, parsedResponse);
            }).catch(function (err) {
              if (enableRetry) if (retryCount < maxRetries) {
                setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
                retryCount += 1;
                return;
              }
              var error = new NetworkError(err.message, {
                originalRequest: request,
                retryCount: retryCount
              });
              maskAuthData(error.originalRequest, maskSensitiveHeaderData);
              next(request, _objectSpread2(_objectSpread2({}, response), {}, {
                error: error,
                statusCode: 0
              }));
            });
            return;
          } // Server responded with an error. Try to parse it as JSON, then
          // return a proper error type with all necessary meta information.


          res.text().then(function (text) {
            // Try to parse the error response as JSON
            var parsed;

            try {
              parsed = JSON.parse(text);
            } catch (error) {
              parsed = text;
            }

            var error = createError(_objectSpread2({
              statusCode: res.status,
              originalRequest: request,
              retryCount: retryCount,
              headers: parseHeaders(res.headers)
            }, _typeof(parsed) === 'object' ? {
              message: parsed.message,
              body: parsed
            } : {
              message: parsed,
              body: parsed
            }));

            if (enableRetry && (retryCodes.indexOf(error.statusCode) !== -1 || (retryCodes === null || retryCodes === void 0 ? void 0 : retryCodes.indexOf(error.message)) !== -1)) {
              if (retryCount < maxRetries) {
                setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
                retryCount += 1;
                return;
              }
            }

            maskAuthData(error.originalRequest, maskSensitiveHeaderData); // Let the final resolver to reject the promise

            var parsedResponse = _objectSpread2(_objectSpread2({}, response), {}, {
              error: error,
              statusCode: res.status
            });

            next(request, parsedResponse);
          }).catch(function (err) {
            if (enableRetry) if (retryCount < maxRetries) {
              setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
              retryCount += 1;
              return;
            }
            var error = new InternalServerError(err.message, {
              originalRequest: request,
              retryCount: retryCount
            });
            maskAuthData(error.originalRequest, maskSensitiveHeaderData);
            next(request, _objectSpread2(_objectSpread2({}, response), {}, {
              error: error,
              statusCode: 500
            }));
          });
        }, // We know that this is a "network" error thrown by the `fetch` library
        function (e) {
          if (enableRetry) if (retryCount < maxRetries) {
            setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
            retryCount += 1;
            return;
          }
          var error = new NetworkError(e.message, {
            originalRequest: request,
            retryCount: retryCount
          });
          maskAuthData(error.originalRequest, maskSensitiveHeaderData);
          next(request, _objectSpread2(_objectSpread2({}, response), {}, {
            error: error,
            statusCode: 0
          }));
        }).finally(function () {
          clearTimeout(timer);
        });
      }

      executeFetch();
    };
  };
}

export { createHttpMiddleware, errors, getErrorByCode };
